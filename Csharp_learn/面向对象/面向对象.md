﻿﻿### 对象
- 对象是按照此蓝图分配和配置的内存块
- 由于类是**引用类型**，因此类对象的变量引用该对象在**托管堆上的地址**。 如果将同一类型的第二个变量分配给第一个变量，则两个变量都引用该地址的对象

### 类实例 class （引用类型）
- 用=赋值的时候 p1和p2指向同一个对象

### 结构体实例 struct  （值类型）
- 由于结构是值类型，因此结构对象的变量具有整个对象的副本。 结构的实例也可使用 new 运算符来创建，但这不是必需的
- p1 和 p2 的内存在线程堆栈上进行分配。 该内存随声明它的类型或方法一起回收。 这就是在赋值时复制结构的一个原因
- 用=赋值的时候 p2 复制了一个对象，内容和p1相同，但它们是两个不同的对象


若要确定两个类实例中字段的值是否相等，可以使用 Equals 方法或 == 运算符。 但是，只有类通过重写或重载提供关于那种类型对象的“相等”含义的自定义时，才能使用它们。 类也可能实现 IEquatable<T> 接口或 IEqualityComparer<T> 接口。 这两个接口都提供可用于测试值相等性的方法。 设计好替代 Equals 的类后，请务必遵循如何为类型定义值相等性和 Object.Equals(Object) 中介绍的准则。


### 继承
- 结构不支持继承，但它们可以实现接口
- 派生只能有一个基类，但是继承是可以传递的，派生类可以做别的派生类的基类
- 只能在派生类中使用 sealed，表示封闭，无法被再次重写

### 虚拟 
- 基类的方法类型是 abstract抽象的 或者是virtual虚拟的 才可以用override重写
- 实例化一个派生类，声明一个基类赋值派生类的实例，调用基类方法会调用到被重写的派生类方法
- 如果在派生类中不想继承基类的方法，但是想用**同名的**可以用**new**关键字 添加在 方法返回类型的前面  （使用新成员隐藏基类成员）
- sealed overrider 从这里开始继承 前面的 A B都不算了

### base关键字
- base.doWork() 访问基类的成员