## 时间复杂度和空间复杂度

表示随着输入数据量的增大，时间和空间增长的快慢

### 时间复杂度

设输入数据大小为 n ，常见的时间复杂度类型如图 2-9 所示（按照从低到高的顺序排列）。

![image-20231212160845385](https://cdn.jsdelivr.net/gh/humoyun1798/image/image/imagessimage-20231212160845385.png)

![time_complexity_common_types](https://cdn.jsdelivr.net/gh/humoyun1798/image/image/imagesstime_complexity_common_types.png)

图 2-9  常见的时间复杂度类型

## 递归 和 迭代（循环）

递归函数自己调用自己

- 递归比迭代更费内存，因为每次迭代都会开辟新的内存，直到完全跑完返回后才会释放内存
- 而且递归产生有额外的系统开销，所以时间效率也会较低

递归次数太多会栈溢出

### 尾递归

编译器不需要保存上下文，会自己优化

有些编译器没有尾递归优化，比如python 所以也会栈溢出

![image-20231212150912072](https://cdn.jsdelivr.net/gh/humoyun1798/image/image/imagessimage-20231212150912072.png)

- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
- 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用<u>分治思想</u>进行分析



### 两者对比

总结以上内容，如表 2-1 所示，迭代和递归在实现、性能和适用性上有所不同。

表 2-1  迭代与递归特点对比

|          | 迭代                                   | 递归                                                         |
| :------- | :------------------------------------- | :----------------------------------------------------------- |
| 实现方式 | 循环结构                               | 函数调用自身                                                 |
| 时间效率 | 效率通常较高，无函数调用开销           | 每次函数调用都会产生开销                                     |
| 内存使用 | 通常使用固定大小的内存空间             | 累积函数调用可能使用大量的栈帧空间                           |
| 适用问题 | 适用于简单循环任务，代码直观、可读性好 | 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 |

```c#
Stack<int> stack = new Stack<int>();
stack.Push(i); //入栈   尾入 1,2,3,4,5， 
stack.Pop();//出栈	尾出 5
```

